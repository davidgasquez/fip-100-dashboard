---
import { readFileSync } from "node:fs";

type CsvRow = Record<string, string>;

type Props = {
	csvPath: string;
	xKey: string;
	yKey: string;
	width?: number;
	height?: number;
	stroke?: string;
	background?: string;
};

const {
	csvPath,
	xKey,
	yKey,
	width = 820,
	height = 260,
	stroke = "#111111",
	background = "#ffffff",
}: Props = Astro.props;

const projectRoot = new URL("../../../", import.meta.url);
const csvFileUrl = new URL(csvPath, projectRoot);
const csvRaw = readFileSync(csvFileUrl, "utf-8").trim();

const parseCsv = (raw: string): CsvRow[] => {
	const lines = raw
		.split(/\r?\n/)
		.map((line) => line.trim())
		.filter(Boolean);

	const [headerLine, ...rows] = lines;
	if (!headerLine) {
		return [];
	}

	const headers = headerLine.split(",").map((cell) => cell.trim());

	return rows.map((row) => {
		const cells = row.split(",").map((cell) => cell.trim());
		return headers.reduce<CsvRow>((acc, header, index) => {
			acc[header] = cells[index] ?? "";
			return acc;
		}, {});
	});
};

const records = parseCsv(csvRaw);

if (!records.length) {
	throw new Error(`LineChart: CSV file "${csvPath}" is empty or invalid`);
}

type DataPoint = {
	x: number;
	xLabel: string;
	y: number;
};

const data: DataPoint[] = records
	.map((row) => {
		const xValue = row[xKey];
		const yValue = Number(row[yKey]);

		if (!xValue) {
			throw new Error(`LineChart: missing "${xKey}" in CSV row`);
		}

		if (Number.isNaN(yValue)) {
			throw new Error(
				`LineChart: value for "${yKey}" is not a number (${row[yKey] ?? "n/a"})`,
			);
		}

		return {
			x: new Date(xValue).getTime(),
			xLabel: xValue,
			y: yValue,
		};
	})
	.sort((a, b) => a.x - b.x);

if (data.length < 2) {
	throw new Error("LineChart: need at least two data points for a line");
}

const xMin = data[0].x;
const xMax = data[data.length - 1].x;
const xRange = Math.max(xMax - xMin, 1);

const yMin = 0;
const yMaxBase = Math.max(...data.map((point) => point.y), yMin);
const yPadding = yMaxBase === yMin ? Math.max(yMaxBase * 0.1, 1) : yMaxBase * 0.1;
const yMax = yMaxBase + yPadding;
const yRange = Math.max(yMax - yMin, 1);

const margin = { top: 20, right: 16, bottom: 32, left: 54 };
const innerWidth = width - margin.left - margin.right;
const innerHeight = height - margin.top - margin.bottom;

const toX = (value: number) =>
	margin.left + ((value - xMin) / xRange) * innerWidth;

const toY = (value: number) =>
	margin.top + (1 - (value - yMin) / yRange) * innerHeight;

const pathData = data
	.map((point, index) => {
		const prefix = index === 0 ? "M" : "L";
		return `${prefix}${toX(point.x).toFixed(2)} ${toY(point.y).toFixed(2)}`;
	})
	.join(" ");

const formatDate = (iso: string) =>
	new Intl.DateTimeFormat("en-US", {
		month: "short",
		day: "numeric",
	}).format(new Date(iso));

const formatNumber = (value: number) =>
	new Intl.NumberFormat("en-US", {
		maximumFractionDigits: 0,
	}).format(value);

const tickCount = 4;
const yStep = (yMax - yMin) / Math.max(tickCount - 1, 1);
const yTicks = Array.from({ length: tickCount }, (_, index) => {
	const value = yMax - index * yStep;
	return {
		value,
		y: toY(value),
		label: formatNumber(value),
	};
});

const xTickIndexes = [0, Math.floor(data.length / 2), data.length - 1];
const xTickPoints: DataPoint[] = [];
const seenX = new Set<number>();

for (const index of xTickIndexes) {
	const point = data[index];
	if (!point || seenX.has(point.x)) {
		continue;
	}
	seenX.add(point.x);
	xTickPoints.push(point);
}

const xTicks = xTickPoints.map((point) => ({
	x: toX(point.x),
	label: formatDate(point.xLabel),
}));

const referenceDateIso = "2025-04-07";
const referenceTimestamp = new Date(referenceDateIso).getTime();
const referenceX =
	Number.isFinite(referenceTimestamp) &&
	referenceTimestamp >= xMin &&
	referenceTimestamp <= xMax
		? toX(referenceTimestamp)
		: null;

const latest = data[data.length - 1];
---

<figure class="chart">
	<svg
		viewBox={`0 0 ${width} ${height}`}
		role="img"
		aria-label={`Line chart for ${yKey} over ${xKey}`}
	>
		<title>{`${yKey} over ${xKey}`}</title>
		<rect
			x="0"
			y="0"
			width={width}
			height={height}
			fill={background}
		/>

		{yTicks.map((tick) => (
			<line
				class="chart__grid"
				x1={margin.left}
				y1={tick.y}
				x2={width - margin.right}
				y2={tick.y}
			/>
		))}

		{referenceX !== null && (
			<line
				class="chart__reference-line"
				x1={referenceX}
				y1={margin.top}
				x2={referenceX}
				y2={height - margin.bottom}
			/>
		)}

		<path class="chart__line" d={pathData} stroke={stroke} />

		<circle cx={toX(latest.x)} cy={toY(latest.y)} r="4" fill={stroke} />

		{yTicks.map((tick) => (
			<text
				class="chart__label chart__label--y"
				x={margin.left - 8}
				y={tick.y}
				dominant-baseline="middle"
			>
				{tick.label}
			</text>
		))}

		{xTicks.map((tick) => (
			<text
				class="chart__label chart__label--x"
				x={tick.x}
				y={height - margin.bottom + 22}
				text-anchor="middle"
			>
				{tick.label}
			</text>
		))}

		<line
			class="chart__axis"
			x1={margin.left}
			y1={height - margin.bottom}
			x2={width - margin.right}
			y2={height - margin.bottom}
		/>
		<line
			class="chart__axis"
			x1={margin.left}
			y1={margin.top}
			x2={margin.left}
			y2={height - margin.bottom}
		/>
	</svg>
</figure>

<style>
	figure.chart {
		margin: 0;
	}

	.chart svg {
		display: block;
		width: 100%;
		height: auto;
	}

	.chart__line {
		fill: none;
		stroke-width: 2;
	}

	.chart__reference-line {
		stroke: #b42318;
		stroke-width: 1.5;
		stroke-dasharray: 4 4;
	}

	.chart__grid {
		stroke: #e0e0e0;
		stroke-width: 1;
	}

	.chart__axis {
		stroke: #111;
		stroke-width: 1.5;
	}

	.chart__label {
		fill: #111;
		font-size: 12px;
		font-weight: 400;
	}

	.chart__label--y {
		text-anchor: end;
	}

	.chart__label--x {
		font-weight: 500;
	}
</style>
